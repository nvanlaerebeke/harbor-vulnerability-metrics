using Serilog.Core;
using VulnerabilityMetrics.DataSource.Harbor.Request;

namespace VulnerabilityMetrics.DataSource.Harbor;

internal class ProjectProvider
{
    private const int CachePeriod = 3600 * 24;
    private readonly HarborApi _harborApi;
    private readonly Logger _log;
    private readonly PeriodicTimer _clearCacheTimer;
    private IEnumerable<string> _projects = Enumerable.Empty<string>();
    
    public ProjectProvider(HarborApi harborApi, Logger log)
    {
        _harborApi = harborApi;
        _log = log;
        _clearCacheTimer = new PeriodicTimer(TimeSpan.FromSeconds(CachePeriod));
        
        //Cache needs to be cleared now and then
        StartCacheCleanupTimer();
    }

    public async Task<IEnumerable<string>> Get()
    {
        if (_projects.Any())
        {
            _log.Information("Returning {Count} projects from cache", _projects.Count());
            return _projects;
        }

        try
        {
            _log.Information("Project cache empty, fetching from API");

            var result = await _harborApi.SendAsyncWithListResponse<Project>(new GetProjectsRequest());
            _projects = result.Select(p =>
            {
                _log.Information("Found project '{project}'", p.Name);
                return p.Name;
            }).ToList();
            return _projects;
        }
        catch (Exception ex)
        {
            _log.Error(ex, "Unable to get updated project list");
            return _projects;
        }
    }

    private void StartCacheCleanupTimer()
    {
        Task.Run(async () =>
        {
            _log.Information("Project cache duration is configured to be {CachePeriod} seconds", CachePeriod);
            while (await _clearCacheTimer.WaitForNextTickAsync())
            {
                _log.Information("Clearing project cache");
                _projects = Enumerable.Empty<string>();
            }
        });
    }
}