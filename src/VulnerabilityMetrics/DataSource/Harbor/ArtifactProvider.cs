using System.Text.Json;
using VulnerabilityMetrics.DataSource.Harbor.Request;

namespace VulnerabilityMetrics.DataSource.Harbor;

internal class ArtifactProvider
{
    private readonly Dictionary<string, Dictionary<string, Dictionary<string, Artifact>>> _artifacts = new();
    private readonly HarborApi _harborApi;

    public ArtifactProvider(HarborApi harborApi)
    {
        _harborApi = harborApi;
    }

    public async Task<Dictionary<string, Artifact>> Get(string project, string repository)
    {
        if (_artifacts.TryGetValue(project, out var repositories))
        {
            if (repositories.TryGetValue(repository, out var tags))
            {
                //ToDo: check for updates
                return tags;
            }
        }

        try
        {
            var tagsToMonitor = JsonSerializer.Deserialize<List<string>>(Environment.GetEnvironmentVariable("TAGS")!);
            //Nothing to monitor
            if (tagsToMonitor is null)
            {
                Console.WriteLine("No tags to monitor found");
                return new Dictionary<string, Artifact>();
            }
            var artifacts = await GetArtifacts(project, repository, tagsToMonitor);
            if (!_artifacts.ContainsKey(project))
            {
                _artifacts.Add(project, new Dictionary<string, Dictionary<string, Artifact>> { { repository, artifacts } });
            }
            _artifacts[project][repository] = artifacts;
            return artifacts;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
            return new Dictionary<string, Artifact>();
        }
    }

    /// <summary>
    ///     Gets the latest artifact for the tags to be monitored
    /// </summary>
    /// <param name="project">Project to get the artifacts for</param>
    /// <param name="repository">Repository to get the artifacts for</param>
    /// <param name="tags">tags to get the artifacts for</param>
    /// <returns>
    ///     Dictionary of the tag name with the latest artifact found for that tag
    ///     If no artifact can be found for a given tag the Dictionary will not contain that tag
    /// </returns>
    private async Task<Dictionary<string, Artifact>> GetArtifacts(string project, string repository, List<string> tags)
    {
        var page = 0;
        var page_size = 100;
        var artifactsForTags = new Dictionary<string, Artifact>();
        int lastResponseAmount;

        do
        {
            var request = new GetArtifactsRequest(project, repository);
            request.SetPagination(++page, page_size);
            request.AddSorting("-push_time");

            var artifacts = await _harborApi.SendAsyncWithListResponse<Artifact>(request);
            lastResponseAmount = artifacts.Count;

            foreach (var artifact in artifacts)
            {
                AddTagIfNeeded(artifact, tags, artifactsForTags);
                //Has a value for every tag that is to be monitored 
                if (artifactsForTags.Count.Equals(tags.Count))
                {
                    return artifactsForTags;
                }
            }
        } while (lastResponseAmount > 0);

        return artifactsForTags;
    }

    private static void AddTagIfNeeded(Artifact artifact, List<string> tags, Dictionary<string, Artifact> artifactsForTags)
    {
        foreach (var tag in artifact.Tags)
        {
            //Tag is not monitored
            if (!tags.Contains(tag.Name))
            {
                return;
            }

            //Already has the latest artifact for the tag
            if (artifactsForTags.ContainsKey(tag.Name))
            {
                return;
            }
            artifactsForTags.Add(tag.Name, artifact);
        }
    }
}