using System.Text.Json;
using Serilog.Core;
using VulnerabilityMetrics.DataSource.Harbor.Request;

namespace VulnerabilityMetrics.DataSource.Harbor;

internal class ArtifactProvider
{
    private const int CachePeriod = 3600;
    private const int PageSize = 100;
    private readonly Dictionary<string, Dictionary<string, Dictionary<string, Artifact>>> _artifacts = new();
    private readonly HarborApi _harborApi;
    private readonly Logger _log;
    private readonly PeriodicTimer _clearCacheTimer;

    public ArtifactProvider(HarborApi harborApi, Logger log)
    {
        _harborApi = harborApi;
        _log = log;
        _clearCacheTimer = new PeriodicTimer(TimeSpan.FromSeconds(CachePeriod));
        
        //Cache needs to be cleared now and then
        StartCacheCleanupTimer();
    }

    public async Task<Dictionary<string, Artifact>> Get(string project, string repository)
    {
        if (_artifacts.TryGetValue(project, out var repositories))
        {
            if (repositories.TryGetValue(repository, out var tags))
            {
                _log.Information("Returning {Count} projects from cache", tags.Count);
                return tags;
            }
        }

        try
        {
            var tagsToMonitor = JsonSerializer.Deserialize<List<string>>(Environment.GetEnvironmentVariable("TAGS")!);
            //Nothing to monitor
            if (tagsToMonitor is null)
            {
                _log.Error("No tags to monitor found, please set environment variable TAGS (json array)");
                return new Dictionary<string, Artifact>();
            }
            var artifacts = await GetArtifacts(project, repository, tagsToMonitor);
            if (!_artifacts.ContainsKey(project))
            {
                _artifacts.Add(project, new Dictionary<string, Dictionary<string, Artifact>> { { repository, artifacts } });
            }
            _artifacts[project][repository] = artifacts;
            return artifacts;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
            return new Dictionary<string, Artifact>();
        }
    }

    /// <summary>
    ///     Gets the latest artifact for the tags to be monitored
    /// </summary>
    /// <param name="project">Project to get the artifacts for</param>
    /// <param name="repository">Repository to get the artifacts for</param>
    /// <param name="tags">tags to get the artifacts for</param>
    /// <returns>
    ///     Dictionary of the tag name with the latest artifact found for that tag
    ///     If no artifact can be found for a given tag the Dictionary will not contain that tag
    /// </returns>
    private async Task<Dictionary<string, Artifact>> GetArtifacts(string project, string repository, ICollection<string> tags)
    {
        var page = 0;
        var artifactsForTags = new Dictionary<string, Artifact>();
        int lastResponseAmount;

        do
        {
            var request = new GetArtifactsRequest(project, repository);
            request.SetPagination(++page, PageSize);
            request.AddSorting("-push_time");

            var artifacts = await _harborApi.SendAsyncWithListResponse<Artifact>(request);
            lastResponseAmount = artifacts.Count;

            foreach (var artifact in artifacts)
            {
                if (artifact.Tags is null || !artifact.Tags.Any())
                {
                    continue;
                }

                AddTagIfNeeded(project, repository, artifact, tags, artifactsForTags);
                //Has a value for every tag that is to be monitored 
                if (artifactsForTags.Count.Equals(tags.Count))
                {
                    return artifactsForTags;
                }
            }
        } while (lastResponseAmount > 0);

        return artifactsForTags;
    }

    private void AddTagIfNeeded(string project, string repository, Artifact artifact, ICollection<string> tags, IDictionary<string, Artifact> artifactsForTags)
    {
        if (artifact.Tags is null)
        {
            return;
        }

        foreach (var tag in artifact.Tags)
        {
            //Tag is not monitored
            if (!tags.Contains(tag.Name))
            {
                return;
            }

            _log.Information("Found tag {project}/{repository}:{tag}", project, repository, tag.Name);
            //Already has the latest artifact for the tag
            if (artifactsForTags.ContainsKey(tag.Name))
            {
                return;
            }
            artifactsForTags.Add(tag.Name, artifact);
        }
    }

    private void StartCacheCleanupTimer()
    {
        Task.Run(async () =>
        {
            _log.Information("Repository cache duration is configured to be {CachePeriod} seconds", CachePeriod);
            while (await _clearCacheTimer.WaitForNextTickAsync())
            {
                _log.Information("Clearing repository cache");
                _artifacts.Clear();
            }
        });
    }
}